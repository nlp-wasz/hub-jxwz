# 【作业1】接口设计

## 请求体 和 响应体

```python
# ClassType.py


# 请求体 和 响应体 结构
from pydantic import BaseModel, Field
from typing import Union, List, Dict


# 数据管理接口 请求（不是必需的，根据接口传递不同的信息）
class DataRequest(BaseModel):
    # 知识库ID（查询、删除、修改、更新 时使用）
    knowledge_id: int = Field(description="知识库ID")
    # 知识库类型
    knowledge_category: str = Field(description="知识库类别")

    # 文档ID（查询、删除、修改、更新 时使用）
    document_id: int = Field(description="文档ID")
    # 文档类别（pdf、text等）
    document_category: str = Field(description="文档类别")
    # 文档标题（根据 标题删除文档）
    document_title: str = Field(description="文档标题")


class DataResponse(BaseModel):
    # 知识库ID
    knowledge_id: int = Field(description="知识库ID")
    # 知识库类型
    knowledge_category: str = Field(description="知识库类别")

    # 文档ID
    document_id: int = Field(description="文档ID")
    # 文档类别
    document_category: str = Field(description="文档类别")
    # 文档标题
    document_title: str = Field(description="文档标题")

    # 响应code
    code: int = Field(description="响应码")
    # 响应结果
    result: Union[List, Dict] = Field(description="响应结果")
    # 响应信息
    message: str = Field(description="响应信息")


# 检索 请求体
class SearchRequest(BaseModel):
    # 检索 知识库类别
    knowledge_category: str = Field(description="知识库类别")
    # 检索 文档类别
    document_category: str = Field(description="文档类别")
    # 检索 文档标题
    document_title: str = Field(description="文档标题")
    # 检索 类型（文本检索、图片检索）
    # 例如文本检索：默认使用 文搜文、文搜图两种方式，检索后采用RAG的 进行多路召回、融合排序、重排序等流程，得到最终结果
    search_category: str = Field(description="检索 类型（文本检索、图片检索）")
    # 编码模型（clip、bge等）
    # 例如文本检索：文搜文时对文本采用不同模型，使用milvus中与之对应的向量字段进行检索
    encoder_model: str = Field(description="编码模型（clip、bge等）")


# 检索 响应体
class SearchResponse(BaseModel):
    # 检索 知识库类别
    knowledge_category: str = Field(description="知识库类别")
    # 检索 文档类别
    document_category: str = Field(description="文档类别")
    # 检索 类型（文本检索、图片检索）
    # 例如文本检索：默认使用 文搜文、文搜图两种方式，检索后采用RAG的 进行多路召回、融合排序、重排序等流程，得到最终结果
    search_category: str = Field(description="检索 类型（文本检索、图片检索）")
    # 编码模型（clip、bge等）
    # 例如文本检索：文搜文时对文本采用不同模型，使用milvus中与之对应的向量字段进行检索
    encoder_model: str = Field(description="编码模型（clip、bge等）")

    # 响应code
    code: int = Field(description="响应码")
    # 响应结果
    result: Union[List, Dict] = Field(description="响应结果")
    # 响应信息
    message: str = Field(description="响应信息")


# 问答 请求体
class QuestionAnswerRequest(BaseModel):
    # 问答 知识库类别
    knowledge_category: str = Field(description="知识库类别")
    # 问答 文档类别
    document_category: str = Field(description="文档类别")
    # 问题
    question_content: str = Field(description="问题内容")


# 问答 响应体
class QuestionAnswerResponse(BaseModel):
    # 问答 知识库类别
    knowledge_category: str = Field(description="知识库类别")
    # 问答 文档类别
    document_category: str = Field(description="文档类别")
    # 问题
    question_content: str = Field(description="问题内容")

    # 响应code
    code: int = Field(description="响应码")
    # 响应结果
    result: Union[List, Dict] = Field(description="响应结果")
    # 响应信息
    message: str = Field(description="响应信息")


```



## Milvus 操作类

```python
# milvus 向量数据库 连接以及 crud操作
from pymilvus import MilvusClient

milvus = MilvusClient(
    uri="https://in03-ea649a98922260d.serverless.ali-cn-hangzhou.cloud.zilliz.com.cn",
    token="9b0e2118eb315fa0ab7ec3d5a2a9512de2542df33f84f168879aaec757f0ba8825041ae0a35596137a4b9bf2aa7bf176bffb8b53",
)
```



## Sqlite 操作类

```python
# Sqlite 连接以及映射关系
import datetime

from sqlalchemy import create_engine, Column, String, ForeignKey, Integer, Index, DateTime, Text
from sqlalchemy.orm import sessionmaker, relationship, declarative_base

sqlite = create_engine(
    "sqlite:///C:\\ai\\project\\nlpPreviev\\week01\\week11-多模态检索与问答\\05_multimodel-rag-chatbot-project\\data\\multimodel.db")
# if sqlite:
#     print("连接成功")


Session = sessionmaker(bind=sqlite)

# 创建 Base
Base = declarative_base()


# 创建 映射关系Class
class Knowledge(Base):
    __tablename__ = 'knowledge'
    __table_args__ = (
        Index("knowledge_id", "knowledge_id"),
    )

    # 知识库 ID
    knowledge_id = Column(Integer, primary_key=True, autoincrement=True)
    # 知识库 类别
    knowledge_category = Column(String(50), nullable=False)
    # 创建人
    create_people = Column(String(50))
    # 创建时间
    create_time = Column(DateTime, default=datetime.datetime.now())
    # 更新时间
    update_time = Column(DateTime, default=datetime.datetime.now(), onupdate=datetime.datetime.now())

    # relationship 关联
    documents = relationship("Document", back_populates="knowledge")

    # 对象输出形式
    def __str__(self):
        return (f"KnowledgeDatabase(knowledge_id={self.knowledge_id}, "
                f"knowledge_category={self.knowledge_category}, "
                f"create_people={self.create_people}, "
                f"create_time={self.create_time}, "
                f"update_time={self.update_time})")


class Document(Base):
    __tablename__ = 'document'
    __table_args__ = (
        Index("document_id", "document_id"),
        Index("foreignkey_knowledge_id", "knowledge_id"),
    )

    # 文档ID
    document_id = Column(Integer, primary_key=True, autoincrement=True)
    # 外键 关联 Knowledge 表
    knowledge_id = Column(Integer, ForeignKey('knowledge.knowledge_id'))
    # milvus 主键ID
    milvus_id = Column(Integer)

    # 文档类别
    document_category = Column(String(50))
    # 文档标题
    document_title = Column(String(200))
    # 文档页码
    document_page = Column(String(10))
    # 文档页码内容分块 chunk ID
    document_chunk_id = Column(String(10))
    # 文档页码内容分块 chunk 内容
    document_chunk_content = Column(Text(length=1024))
    # 文档页码内容 图片存储地址
    document_image_path = Column(String(200))
    # 创建人
    create_people = Column(String(50))
    # 创建时间
    create_time = Column(DateTime, default=datetime.datetime.now())
    # 更新时间
    update_time = Column(DateTime, default=datetime.datetime.now(), onupdate=datetime.datetime.now())

    # relationship 关联
    knowledge = relationship("Knowledge", back_populates="documents")

    # 对象输出形式
    def __str__(self):
        return (f"Document(document_id={self.document_id}, "
                f"document_category={self.document_category}, "
                f"document_title={self.document_title}, "
                f"document_page={self.document_page}, "
                f"document_chunk_id={self.document_chunk_id}), "
                f"document_chunk_content={self.document_chunk_content}), "
                f"document_image_path={self.document_image_path}), "
                f"create_people={self.create_people}), "
                f"create_time={self.create_time}), "
                f"update_time={self.update_time})")


# 创建 表
def create_tables():
    Base.metadata.drop_all(bind=sqlite)
    Base.metadata.create_all(bind=sqlite)


# create_tables()

```



## FastAPI 模块

```python
# fastapi 接口
from fastapi import FastAPI, Form, UploadFile, File, Depends
from fastapi.openapi.docs import get_swagger_ui_html
from starlette.responses import HTMLResponse

from ClassType import (
    DataRequest, DataResponse,
    SearchRequest, SearchResponse,
    QuestionAnswerRequest, QuestionAnswerResponse
)
from SqliteDB import Session
from typing import Optional

# 创建 FastAPI实例
api = FastAPI(
    title='多模态RAG聊天+图文问答',
    description='多模态RAG聊天+图文问答',
    version='0.0.1',
    docs_url=None
)


# fastapi页面swagger方式默认加载境外资源，这里修改为国内资源
@api.get("/docs", include_in_schema=False)
async def custom_swagger_ui() -> HTMLResponse:
    return get_swagger_ui_html(
        openapi_url="/openapi.json",
        title="API 文档",
        swagger_js_url="https://unpkg.com/swagger-ui-dist@5.9.0/swagger-ui-bundle.js",
        swagger_css_url="https://unpkg.com/swagger-ui-dist@5.9.0/swagger-ui.css",
    )


def get_sqlite_session():
    session = Session()
    try:
        yield session
    finally:
        session.close()


# 一：数据管理接口
# 1.新增文档信息
@api.post("/add_document_info", description="新增文档信息", response_model=DataResponse)
def add_document_info(request: DataRequest, upload_document: Optional[UploadFile] = File(...),
                      session=Depends(get_sqlite_session)):
    data_response = DataResponse(
        code=200,
        message="新增成功"
    )

    # 文档解析
    # 对解析结果进行处理（使用langchain进行文本chunk、图片地址等信息提取构建）
    # 将 图文 信息，保存至 sqlite 和 milvus（也可以再增加elasticsearch，进行全文检索、语义向量检索，与milvus检索结果进行多路融合排序）

    return data_response


# 2.删除文档信息（根据知识库ID、类别，文档ID、类别、标题等）
@api.post("/delete_document_info", description="删除文档信息", response_model=DataResponse)
def delete_document_info(request: DataRequest, session=Depends(get_sqlite_session)):
    data_response = DataResponse(
        code=200,
        message="删除成功"
    )

    # 先从 sqlite中查询文档信息，再删除
    # 根据 document.milvus_id 删除milvus中相关信息

    return data_response


# 3.修改文档信息（修改标题、上传新的pdf文档等）
@api.post("/update_document_info", description="修改文档信息", response_model=DataResponse)
def update_document_info(request: DataRequest, upload_document: Optional[UploadFile] = File(None),
                         session=Depends(get_sqlite_session)):
    data_response = DataResponse(
        code=200,
        message="修改成功"
    )

    # sqlite 查询原始文档信息
    # 在sqlite中删除 knowledge和document信息
    # 重新解析 pdf文档，添加信息

    # milvus 中先删除（根据knowledge_id和document_id） 后添加

    return data_response


# 4.查询文档信息
@api.post("/query_document_info", description="查询文档信息", response_model=DataResponse)
def query_document_info(request: DataRequest, session=Depends(get_sqlite_session)):
    data_response = DataResponse(
        code=200,
        message="查询成功"
    )

    # 从 sqlite中查询

    return data_response


# 5.检索文档信息（统一检索接口，所有检索类型都调用这个API）
@api.post("/search_document_info", description="检索文档信息", response_model=SearchResponse)
def search_document_info(request: SearchRequest, search_image: Optional[UploadFile] = File(None),
                         session=Depends(get_sqlite_session)):
    data_response = DataResponse(
        code=200,
        message="检索成功"
    )

    # 判断检索方式（request.search_category：文本检索、图片检索）
    # 调用检索方法（根据request.encoder_model 对文本进行编码 clip、beg等，）
    # 使用 milvus 检索API，获取检索结果
    # 根据 milvus中knowledge_id和document_id字段，获取检索结果详细信息

    return data_response


# 6.图文问答
@api.post("/question_answer", description="图文问答", response_model=QuestionAnswerResponse)
def search_document_info(request: QuestionAnswerRequest, qa_image: Optional[UploadFile] = File(None),
                         session=Depends(get_sqlite_session)):
    data_response = DataResponse(
        code=200,
        message="图文问答"
    )

    # 判断问答方式（文、图文）
    # 对 文、图文 进行编码，在milvus中进行检索
    # 对检索到的结果进行多路召回，融合排序，重排序，获取topK（RAG流程）
    # 根据milvus中的knowledge_id和document_id字段，获取详细信息（文本内容，图片信息）
    # 根据检索到的结果，构建图文问答提示词模板
    # 调用远程多模态模型或本地多模态模型（Qwen-VL），生成回答

    return data_response

```



## ElasticSearch 操作类

```python
# 需要时添加
```

