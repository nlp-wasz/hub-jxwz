### 步骤2: 定义MCP服务，并将每一个公式整理为MCP的一个可执行工具

#### MCP服务架构设计

**MCP服务端实现：**
```python
from mcp.server import Server
from mcp.server.models import InitializationOptions
from mcp.server.stdio import stdio_server
import mcp.types as types

# 创建MCP服务器
server = Server("formula-calculator")

# 注册10个计算工具
MCP_TOOLS = {
    "calculate_complex_system_response": {
        "function": calculate_complex_system_response,
        "description": "计算复杂系统中两个输入变量耦合作用的响应值",
        "keywords": ["复杂系统", "耦合", "非线性", "响应"],
        "formula": "fun(x, y) = 2.5·sin(x) + 1.8·cos(y) + 0.3·x·y"
    },
    "calculate_difference_equation": {
        "function": calculate_difference_equation,
        "description": "基于差分方程计算多输入动态系统输出",
        "keywords": ["差分方程", "动态系统", "时间序列", "反馈"],
        "formula": "y_t = a·x1,t + b·y_t-1 + c·y_t-2 + d·x2,t·x3,t"
    },
    "calculate_cattle_population_growth": {
        "function": calculate_cattle_population_growth,
        "description": "基于逻辑斯蒂增长模型计算牛群数量动态变化",
        "keywords": ["逻辑斯蒂", "种群增长", "承载能力", "生态"],
        "formula": "N_{t+1} = N_t + r·N_t·(1 - N_t/K)"
    },
    "calculate_house_market_value": {
        "function": calculate_house_market_value,
        "description": "基于经验模型估算房产市场价值",
        "keywords": ["房产", "市场价值", "面积", "楼层", "房龄"],
        "formula": "Value = 10000 × Area × (1 + 0.02 × Floor) × (1 − 0.015 × Age)"
    },
    "calculate_food_texture_hardness": {
        "function": calculate_food_texture_hardness,
        "description": "基于线性模型预测食品加工后的质地硬度",
        "keywords": ["食品", "质地硬度", "温度", "时间", "pH", "糖分"],
        "formula": "Texture Hardness = 0.5 × temp + 1.2 × time − 3.0 × ph + 0.8 × sugar"
    },
    "calculate_pollutant_concentration_rate": {
        "function": calculate_pollutant_concentration_rate,
        "description": "计算湖泊中污染物浓度的时间变化率",
        "keywords": ["污染物", "浓度", "湖泊", "环境", "降解"],
        "formula": "dC/dt = [Q_in × (C_in - C)] / V - k × C"
    },
    "calculate_environmental_quality_index": {
        "function": calculate_environmental_quality_index,
        "description": "计算环境质量指数EQI",
        "keywords": ["环境质量", "EQI", "污染", "人口密度", "绿化"],
        "formula": "EQI = 100 - [pollution_level / (1 + population_density)] × (1 - green_coverage)"
    },
    "calculate_car_fuel_consumption": {
        "function": calculate_car_fuel_consumption,
        "description": "基于线性模型预测汽车百公里油耗",
        "keywords": ["汽车", "油耗", "重量", "燃料"],
        "formula": "fuel_consumption = 0.001 × weight + 5"
    },
    "calculate_complex_system_output": {
        "function": calculate_complex_system_output,
        "description": "计算多变量非线性复杂系统的输出值",
        "keywords": ["复杂系统", "积分", "非线性", "多变量"],
        "formula": "y = ∫₀^x₁ [a·e^(-t/b)] / (c + t) dt + d·x₂² + e·sin(x₃) + log(x₄ + 1) + √x₅"
    },
    "calculate_exponential_population_growth": {
        "function": calculate_exponential_population_growth,
        "description": "计算指数人口增长模型的人口数量",
        "keywords": ["人口", "指数增长", "种群", "增长模型"],
        "formula": "P(t) = P0·e^(r·t)"
    }
}

# 工具注册装饰器
def register_tool(tool_name: str):
    def decorator(func):
        async def wrapper(arguments):
            try:
                result = func(**arguments)
                return {
                    "success": True,
                    "result": result,
                    "tool": tool_name
                }
            except Exception as e:
                return {
                    "success": False,
                    "error": str(e),
                    "tool": tool_name
                }
        return wrapper
    return decorator

# 注册所有工具到MCP服务
for tool_name, tool_info in MCP_TOOLS.items():
    server.add_tool(
        types.Tool(
            name=tool_name,
            description=tool_info["description"],
            inputSchema={
                "type": "object",
                "properties": {
                    "parameters": {
                        "type": "array",
                        "items": {"type": "number"}
                    }
                },
                "required": ["parameters"]
            }
        )
    )
```

#### 工具元数据管理
```python
# 工具元数据存储
TOOL_METADATA = {
    "calculate_complex_system_response": {
        "parameters": ["x", "y"],
        "parameter_types": ["float", "float"],
        "return_type": "float",
        "precision": 1e-6,
        "validation_rules": {
            "x": {"min": -100, "max": 100},
            "y": {"min": -100, "max": 100}
        }
    },
    "calculate_house_market_value": {
        "parameters": ["Area", "Floor", "Age"],
        "parameter_types": ["float", "int", "float"],
        "return_type": "float",
        "precision": 0.01,
        "validation_rules": {
            "Area": {"min": 0, "max": 1000},
            "Floor": {"min": 0, "max": 100},
            "Age": {"min": 0, "max": 100}
        }
    }
    # ... 其他工具的元数据
}
```

### 步骤3: 通过RAG筛选top1/3公式，生成工具白名单

#### RAG检索与工具筛选流程

**1. 用户提问预处理**
```python
def preprocess_user_question(question: str) -> dict:
    """
    预处理用户提问，提取关键词和数值参数
    """
    # 提取关键词
    keywords = extract_keywords(question)

    # 提取数值参数
    numeric_params = extract_numeric_values(question)

    # 意图识别
    intent = classify_question_intent(keywords)

    return {
        "question": question,
        "keywords": keywords,
        "numeric_params": numeric_params,
        "intent": intent
    }
```

**2. RAG检索实现**
```python
class RAGToolSelector:
    def __init__(self, formula_database, embedding_model):
        self.formula_db = formula_database
        self.embedding_model = embedding_model
        self.formula_embeddings = self._build_formula_embeddings()

    def search_relevant_formulas(self, question_data: dict, top_k: int = 3) -> list:
        """
        基于用户问题检索相关公式
        """
        # 生成问题向量
        question_embedding = self.embedding_model.encode(
            question_data["question"] + " " + " ".join(question_data["keywords"])
        )

        # 计算相似度
        similarities = []
        for formula in self.formula_db:
            formula_text = f"{formula['latex']} {formula['context']}"
            formula_embedding = self.embedding_model.encode(formula_text)

            # 余弦相似度
            similarity = np.dot(question_embedding, formula_embedding) / (
                np.linalg.norm(question_embedding) * np.linalg.norm(formula_embedding)
            )

            # 关键词匹配分数
            keyword_score = self._calculate_keyword_match(question_data, formula)

            # 综合评分 (70%语义 + 30%关键词)
            final_score = 0.7 * similarity + 0.3 * keyword_score

            similarities.append({
                "formula": formula,
                "similarity": similarity,
                "keyword_score": keyword_score,
                "final_score": final_score
            })

        # 排序并返回top-k
        similarities.sort(key=lambda x: x["final_score"], reverse=True)
        return similarities[:top_k]

    def generate_tool_whitelist(self, relevant_formulas: list) -> list:
        """
        基于检索到的公式生成工具白名单
        """
        tool_whitelist = []

        for formula_info in relevant_formulas:
            formula_name = formula_info["formula"]["latex"]

            # 匹配公式与MCP工具
            matched_tools = self._match_formula_to_tools(formula_name)

            # 添加到白名单
            for tool_name in matched_tools:
                if tool_name not in tool_whitelist:
                    tool_whitelist.append({
                        "tool_name": tool_name,
                        "confidence": formula_info["final_score"],
                        "formula": formula_info["formula"]
                    })

        return tool_whitelist
```

**3. 工具匹配算法**
```python
def match_formula_to_tools(self, formula_text: str) -> list:
    """
    将公式文本匹配到对应的MCP工具
    """
    matched_tools = []

    # 公式文本标准化
    normalized_formula = self._normalize_formula(formula_text)

    # 遍历所有MCP工具
    for tool_name, tool_info in MCP_TOOLS.items():
        tool_formula = tool_info["formula"]
        normalized_tool_formula = self._normalize_formula(tool_formula)

        # 公式相似度匹配
        if self._formula_similarity(normalized_formula, normalized_tool_formula) > 0.8:
            matched_tools.append(tool_name)

        # 关键词匹配
        elif self._keyword_based_matching(formula_text, tool_info):
            matched_tools.append(tool_name)

    return matched_tools

def _normalize_formula(self, formula: str) -> str:
    """标准化公式文本"""
    # 移除空格和特殊字符
    normalized = re.sub(r'[^\w\+\-\*\/\(\)\[\]\{\}\.=]', '', formula)
    return normalized.lower()

def _formula_similarity(self, formula1: str, formula2: str) -> float:
    """计算两个公式的相似度"""
    # 使用编辑距离计算相似度
    from difflib import SequenceMatcher
    return SequenceMatcher(None, formula1, formula2).ratio()
```

### 步骤4: 调用对应的MCP工具，执行计算，汇总得到回答

#### 智能问答执行引擎
```python
class IntelligentQASystem:
    def __init__(self, mcp_server, rag_selector):
        self.mcp_server = mcp_server
        self.rag_selector = rag_selector
        self.answer_generator = AnswerGenerator()

    async def process_question(self, user_question: str) -> dict:
        """
        完整的问答处理流程
        """
        # 1. 预处理用户问题
        question_data = preprocess_user_question(user_question)

        # 2. RAG检索相关公式
        relevant_formulas = self.rag_selector.search_relevant_formulas(question_data)

        # 3. 生成工具白名单
        tool_whitelist = self.rag_selector.generate_tool_whitelist(relevant_formulas)

        # 4. 执行MCP工具计算
        calculation_results = await self._execute_mcp_tools(
            question_data, tool_whitelist
        )

        # 5. 生成最终回答
        final_answer = self.answer_generator.generate_answer(
            question_data, relevant_formulas, calculation_results
        )

        return final_answer

    async def _execute_mcp_tools(
        self, question_data: dict, tool_whitelist: list
    ) -> list:
        """
        执行MCP工具计算
        """
        results = []

        # 根据置信度排序工具
        sorted_tools = sorted(tool_whitelist, key=lambda x: x["confidence"], reverse=True)

        # 尝试前3个最相关的工具
        for tool_info in sorted_tools[:3]:
            tool_name = tool_info["tool_name"]

            # 参数推断
            inferred_params = self._infer_tool_parameters(
                question_data, tool_name
            )

            if inferred_params:
                # 调用MCP工具
                result = await self.mcp_server.call_tool(tool_name, inferred_params)
                results.append({
                    "tool_name": tool_name,
                    "parameters": inferred_params,
                    "result": result,
                    "confidence": tool_info["confidence"]
                })

        return results

    def _infer_tool_parameters(self, question_data: dict, tool_name: str) -> dict:
        """
        从用户问题中推断工具参数
        """
        # 获取工具元数据
        tool_metadata = TOOL_METADATA.get(tool_name, {})
        required_params = tool_metadata.get("parameters", [])

        inferred_params = {}
        numeric_params = question_data.get("numeric_params", [])

        # 根据工具类型和问题内容推断参数
        if tool_name == "calculate_house_market_value":
            # 房产价值计算
            area = self._extract_parameter(question_data["question"], ["面积", "面积", "平米"], numeric_params)
            floor = self._extract_parameter(question_data["question"], ["楼层", "层", "楼层数"], numeric_params)
            age = self._extract_parameter(question_data["question"], ["房龄", "年", "建成"], numeric_params)

            if area is not None: inferred_params["Area"] = area
            if floor is not None: inferred_params["Floor"] = floor
            if age is not None: inferred_params["Age"] = age

        elif tool_name == "calculate_car_fuel_consumption":
            # 汽车油耗计算
            weight = self._extract_parameter(question_data["question"], ["重量", "车重", "吨"], numeric_params)
            if weight is not None: inferred_params["weight"] = weight

        # 参数验证
        validated_params = self._validate_parameters(tool_name, inferred_params)

        return validated_params if validated_params else None

    def _extract_parameter(self, question: str, keywords: list, numeric_params: list) -> float:
        """从问题中提取特定参数"""
        for keyword in keywords:
            if keyword in question:
                # 返回最接近的数值参数
                return min(numeric_params, key=lambda x: abs(x - 0)) if numeric_params else None
        return None
```

#### 回答生成器
```python
class AnswerGenerator:
    def generate_answer(self, question_data, formulas, calculations):
        """
        生成最终回答
        """
        answer = {
            "question": question_data["question"],
            "relevant_formulas": formulas,
            "calculation_results": calculations,
            "final_answer": "",
            "explanation": "",
            "confidence": 0.0
        }

        if calculations:
            # 选择最佳计算结果
            best_result = max(calculations, key=lambda x: x["confidence"])

            if best_result["result"]["success"]:
                result_value = best_result["result"]["result"]
                tool_name = best_result["tool_name"]

                # 生成最终答案
                answer["final_answer"] = self._format_result(result_value, tool_name)
                answer["explanation"] = self._generate_explanation(answer)
                answer["confidence"] = best_result["confidence"]
            else:
                answer["final_answer"] = "抱歉，计算过程中出现错误。"
                answer["explanation"] = f"错误信息：{best_result['result'].get('error', '未知错误')}"
        else:
            answer["final_answer"] = "抱歉，没有找到相关的计算工具来回答您的问题。"
            answer["explanation"] = "建议您提供更具体的参数信息或检查问题表述。"

        return answer

    def _format_result(self, result, tool_name: str) -> str:
        """格式化计算结果"""
        # 根据工具类型格式化输出
        if "house_market_value" in tool_name:
            return f"该房产的估算价值为 {result:,.0f} 元"
        elif "car_fuel_consumption" in tool_name:
            return f"该汽车的百公里油耗为 {result:.1f} 升"
        elif "population_growth" in tool_name:
            return f"估算的牛群数量为 {result:.0f} 头"
        else:
            return f"计算结果为：{result}"
```

#### 端到端系统测试
```python
# 测试完整问答流程
async def test_end_to_end_system():
    """端到端系统测试"""

    # 初始化系统
    mcp_server = MCPServer()
    rag_selector = RAGToolSelector(formula_database, embedding_model)
    qa_system = IntelligentQASystem(mcp_server, rag_selector)

    # 测试问题
    test_questions = [
        "计算面积100平方米，楼层10层，房龄5年的房产价值",
        "汽车重量1500千克的油耗是多少？",
        "初始牛群100头，增长率0.2，承载能力500头，下一年有多少头？"
    ]

    results = []
    for question in test_questions:
        result = await qa_system.process_question(question)
        results.append(result)
        print(f"问题: {question}")
        print(f"回答: {result['final_answer']}")
        print(f"置信度: {result['confidence']:.2f}")
        print("-" * 50)

    return results
```